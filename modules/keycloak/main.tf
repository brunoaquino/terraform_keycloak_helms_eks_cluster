resource "kubernetes_namespace" "keycloak" {
  count = var.create_namespace ? 1 : 0

  metadata {
    name = var.namespace
  }
}

resource "kubernetes_secret" "keycloak_db" {
  count = var.external_db_enabled ? 1 : 0

  metadata {
    name      = "keycloak-db-secret"
    namespace = var.namespace
  }

  data = {
    "DB_VENDOR"   = "postgres"
    "DB_ADDR"     = var.external_db_host
    "DB_PORT"     = var.external_db_port
    "DB_DATABASE" = var.external_db_database
    "DB_USER"     = var.external_db_username
    "DB_PASSWORD" = var.external_db_password
  }

  depends_on = [
    kubernetes_namespace.keycloak
  ]
}

resource "helm_release" "keycloak" {
  name       = "keycloak"
  repository = "oci://registry-1.docker.io/bitnamicharts"
  chart      = "keycloak"
  version    = var.chart_version
  namespace  = var.namespace
  timeout    = 1200

  # Forçar recriação se o chart ou configurações mudarem
  recreate_pods = true
  force_update  = true

  depends_on = [
    kubernetes_namespace.keycloak,
    kubernetes_secret.keycloak_db
  ]

  # Configurações gerais
  set {
    name  = "fullnameOverride"
    value = "keycloak"
  }

  # Configuração de acesso
  set {
    name  = "service.type"
    value = var.service_type
  }

  # Configuração de usuário e senha administrativos
  set {
    name  = "auth.adminUser"
    value = var.admin_username
  }

  dynamic "set" {
    for_each = var.admin_password != null ? [1] : []
    content {
      name  = "auth.adminPassword"
      value = var.admin_password
    }
  }

  # Configurações de portas
  set {
    name  = "service.ports.http"
    value = "8080"
  }

  set {
    name  = "service.ports.https"
    value = "8443"
  }

  # Configuração de proxy
  set {
    name  = "production"
    value = "true"
  }

  set {
    name  = "extraStartupArgs"
    value = "--hostname=keycloak.${var.base_domain} --proxy-headers=xforwarded --hostname-strict=false"
  }

  # Configuração de TLS
  set {
    name  = "tls.enabled"
    value = "true"
  }

  set {
    name  = "tls.autoGenerated"
    value = "true"
  }

  set {
    name  = "proxyAddressForwarding"
    value = "true"
  }

  # Configurações de recursos
  set {
    name  = "resources.requests.cpu"
    value = "500m"
  }

  set {
    name  = "resources.requests.memory"
    value = "1Gi"
  }

  set {
    name  = "resources.limits.cpu"
    value = "1000m"
  }

  set {
    name  = "resources.limits.memory"
    value = "2Gi"
  }

  # Configurações do banco de dados
  set {
    name  = "postgresql.enabled"
    value = var.external_db_enabled ? "false" : "true"
  }

  # Configurações para PostgreSQL externo
  dynamic "set" {
    for_each = var.external_db_enabled ? [1] : []
    content {
      name  = "externalDatabase.host"
      value = var.external_db_host
    }
  }

  dynamic "set" {
    for_each = var.external_db_enabled ? [1] : []
    content {
      name  = "externalDatabase.port"
      value = var.external_db_port
    }
  }

  dynamic "set" {
    for_each = var.external_db_enabled ? [1] : []
    content {
      name  = "externalDatabase.database"
      value = var.external_db_database
    }
  }

  dynamic "set" {
    for_each = var.external_db_enabled ? [1] : []
    content {
      name  = "externalDatabase.user"
      value = var.external_db_username
    }
  }

  dynamic "set" {
    for_each = var.external_db_enabled ? [1] : []
    content {
      name  = "externalDatabase.password"
      value = var.external_db_password
    }
  }

  dynamic "set" {
    for_each = var.external_db_enabled ? [1] : []
    content {
      name  = "externalDatabase.existingSecret"
      value = ""
    }
  }

  # Configurações para PostgreSQL interno (caso não use externo)
  dynamic "set" {
    for_each = var.external_db_enabled ? [] : [1]
    content {
      name  = "postgresql.persistence.enabled"
      value = "true"
    }
  }

  dynamic "set" {
    for_each = var.external_db_enabled ? [] : [1]
    content {
      name  = "postgresql.persistence.size"
      value = "10Gi"
    }
  }
}

resource "kubernetes_ingress_v1" "keycloak_ingress" {
  count = var.create_ingress && var.enable_https ? 1 : 0

  metadata {
    name      = "keycloak-ingress"
    namespace = var.namespace
    annotations = {
      "kubernetes.io/ingress.class"                         = "nginx"
      "cert-manager.io/cluster-issuer"                      = var.cert_manager_environment == "prod" ? "letsencrypt-prod" : "letsencrypt-staging"
      "nginx.ingress.kubernetes.io/backend-protocol"        = "HTTPS"
      "nginx.ingress.kubernetes.io/ssl-redirect"            = "true"
      "nginx.ingress.kubernetes.io/force-ssl-redirect"      = "true"
      "external-dns.alpha.kubernetes.io/hostname"           = "keycloak.${var.base_domain}"
      "nginx.ingress.kubernetes.io/proxy-buffer-size"       = "128k"
      "nginx.ingress.kubernetes.io/proxy-buffers"           = "4 256k"
      "nginx.ingress.kubernetes.io/proxy-busy-buffers-size" = "256k"
      "nginx.ingress.kubernetes.io/configuration-snippet"   = <<-EOT
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Port 443;
      EOT
    }
  }

  spec {
    rule {
      host = "keycloak.${var.base_domain}"
      http {
        path {
          path      = "/"
          path_type = "Prefix"
          backend {
            service {
              name = "keycloak"
              port {
                name = "https"
              }
            }
          }
        }
      }
    }

    tls {
      hosts       = ["keycloak.${var.base_domain}"]
      secret_name = "keycloak-tls-cert"
    }
  }

  depends_on = [
    helm_release.keycloak
  ]
}
